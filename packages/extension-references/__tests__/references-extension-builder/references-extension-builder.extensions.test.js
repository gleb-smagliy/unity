describe('ReferencesExtensionBuilder:buildSchemaExtensions', () =>
{
  it.skip('should return extensions with ref field name equal to alias name', async () =>
  {
    throw new Error()
  });

  it.skip('should return extensions with ref field of nullable type equal to type from metadata', async () =>
  {
    throw new Error()
  });

  it.skip('should return extensions with ref field of non-nullable type equal to type from metadata', async () =>
  {
    throw new Error()
  });

  it.skip('should return extensions with ref field with additional args equal to args from metadata', async () =>
  {
    throw new Error()
  });

  it.skip('should return resolver, which query schema by key from parent', async () =>
  {
    throw new Error()
  });

  it.skip('should return resolver, which query schema by key from parent and using additional args', async () =>
  {
    throw new Error()
  });

  it.skip('should return failure if type is not valid in metadata model', async () =>
  {
    throw new Error()
  });

  it.skip('should return failure if alias is not valid in metadata model', async () =>
  {
    throw new Error()
  });

  it.skip('should return failure if alias does is not valid in metadata model', async () =>
  {
    throw new Error()
  });

  it.skip('should return failure if key field is not valid in metadata model', async () =>
  {
    throw new Error()
  });

  it.skip('should return failure if key arg is not valid in metadata model', async () =>
  {
    throw new Error()
  });
});